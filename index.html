<!DOCTYPE html>
<html>
<head>
    <title>Gemini Chat Assistant</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Load React, ReactDOM, and Babel for local development -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Custom SVG icons for Send and MessageSquare
        const SendIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <line x1="22" x2="11" y1="2" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
        );

        const MessageSquareIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
        );

        // --- GEMINI API CONSTANTS ---
        const API_KEY = ""; // Canvas environment handles this key
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent";
        // -----------------------------

        // Main Application Component
        const App = () => {
            const [messages, setMessages] = useState([
                { id: 1, text: "Hello! I'm the Gemini Assistant. Type a message below to start our conversation.", sender: 'bot', timestamp: new Date().toISOString() }
            ]);
            const [inputMessage, setInputMessage] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [apiError, setApiError] = useState(null);

            const messagesEndRef = useRef(null);

            const scrollToBottom = () => {
                messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
            };

            useEffect(() => {
                scrollToBottom();
            }, [messages]);

            // --- GEMINI API LOGIC ---

            const callGeminiAPI = async (chatHistory) => {
                const maxRetries = 3;
                let lastError = null;

                // Format conversation history for the Gemini API
                const contents = chatHistory.map(msg => ({
                    // Map internal 'user'/'bot' roles to 'user'/'model' roles required by API
                    role: msg.sender === 'user' ? 'user' : 'model',
                    // Cleanup any residual prefixes from previous versions if they exist
                    parts: [{ text: msg.text.replace(/\[Echo\] You said: "/, '').replace(/"|âœ¨ /g, '') }] 
                }));
                
                // Add the final instruction prompt for the LLM
                contents.push({
                    role: 'user',
                    parts: [{ text: "Based on the conversation above, provide a helpful and conversational next response from the perspective of the assistant. Keep the response concise, polite, and relevant." }]
                });

                const payload = {
                    contents: contents,
                    generationConfig: {
                        // Keep response concise for chat bubble
                        maxOutputTokens: 250, 
                        temperature: 0.7 
                    },
                    systemInstruction: {
                        parts: [{ text: "You are a helpful and friendly chat assistant named Gemini Assistant. You are currently simulating a chat application." }]
                    },
                };

                for (let i = 0; i < maxRetries; i++) {
                    try {
                        let response = await fetch(API_URL + `?key=${API_KEY}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            throw new Error(`API returned status ${response.status}`);
                        }

                        const result = await response.json();
                        const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text || "Error: No text generated.";
                        return generatedText;

                    } catch (error) {
                        lastError = error;
                        // Implement exponential backoff (1s, 2s, 4s)
                        if (i < maxRetries - 1) {
                            await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                        }
                    }
                }
                throw lastError;
            };

            const handleMessageSubmission = async (e) => {
                e.preventDefault();
                const trimmedMessage = inputMessage.trim();
                if (!trimmedMessage) return;

                setApiError(null);
                setIsLoading(true);

                // 1. Add User Message
                const userMessage = { 
                    id: Date.now(), 
                    text: trimmedMessage, 
                    sender: 'user', 
                    timestamp: new Date().toISOString() 
                };
                setInputMessage('');
                setMessages(prev => [...prev, userMessage]);
                
                // 2. Add Temporary Loading Message
                const loadingMessage = { 
                    id: Date.now() + 0.5, 
                    text: "The Gemini Assistant is typing...", 
                    sender: 'bot', 
                    timestamp: new Date().toISOString(),
                    isPending: true
                };
                
                // We calculate the history *before* adding the temporary loading message
                const historyForApi = [...messages, userMessage]; 

                setMessages(prev => [...prev, loadingMessage]);
                scrollToBottom();


                try {
                    const llmResponseText = await callGeminiAPI(historyForApi);

                    // 3. Remove the pending loading message
                    setMessages(prev => prev.filter(msg => !msg.isPending));

                    // 4. Add AI Response
                    const llmMessage = { 
                        id: Date.now() + 1, 
                        text: llmResponseText, 
                        sender: 'bot', 
                        timestamp: new Date().toISOString() 
                    };
                    setMessages(prev => [...prev, llmMessage]);

                } catch (error) {
                    // Remove the pending loading message and add an error message
                    setMessages(prev => prev.filter(msg => !msg.isPending));
                    const errorMessage = `Failed to get a response. (${error.message || 'Network Error'})`;
                    setApiError(errorMessage);
                    setMessages(prev => [...prev, { 
                        id: Date.now() + 1, 
                        text: errorMessage, 
                        sender: 'bot', 
                        timestamp: new Date().toISOString() 
                    }]);
                } finally {
                    setIsLoading(false);
                }
            };
            
            // --- END GEMINI API LOGIC ---

            // Component for rendering a single chat bubble
            const ChatBubble = ({ message }) => {
                const isUser = message.sender === 'user';
                const timestamp = new Date(message.timestamp).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                return (
                    <div className={`message-row ${isUser ? 'user-align' : 'bot-align'}`}>
                        <div 
                            className={`message-bubble ${isUser ? 'user-bubble' : 'bot-bubble'} ${message.isPending ? 'pending-bubble' : ''}`}
                        >
                            <p className="message-text">
                                {message.text}
                            </p>
                            <span className={`message-time ${isUser ? 'user-time' : 'bot-time'}`}>
                                {message.isPending ? '...' : timestamp}
                            </span>
                        </div>
                    </div>
                );
            };

            return (
                <div className="app-container">
                    <div className="chat-window">
                        
                        {/* Header */}
                        <div className="header">
                            <MessageSquareIcon className="icon-large" />
                            <h1>Gemini Chat Assistant</h1>
                        </div>

                        {/* Messages Container */}
                        <div className="messages-container">
                            {messages.map((msg) => (
                                <ChatBubble key={msg.id} message={msg} />
                            ))}
                            <div ref={messagesEndRef} />
                        </div>

                        {/* Input Area */}
                        <form onSubmit={handleMessageSubmission} className="input-form">
                            <input
                                type="text"
                                value={inputMessage}
                                onChange={(e) => setInputMessage(e.target.value)}
                                placeholder={isLoading ? "Please wait for the assistant to reply..." : "Type your message..."}
                                className="input-field"
                                disabled={isLoading}
                            />
                            <button
                                type="submit"
                                disabled={!inputMessage.trim() || isLoading}
                                className="send-button"
                            >
                                {isLoading ? (
                                    <div className="loader spin"></div>
                                ) : (
                                    <SendIcon className="icon-small" />
                                )}
                            </button>
                        </form>

                    </div>
                </div>
            );
        };
        
        // Render the App
        ReactDOM.createRoot(document.getElementById('root')).render(<App />);

    </script>
    <style>
        /* --- General Reset and Typography --- */
        body {
            margin: 0;
            line-height: 1.5;
        }
        .app-container {
            min-height: 100vh;
            background-color: #f3f4f6; /* light grey background */
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            font-family: 'Inter', Arial, sans-serif;
            box-sizing: border-box;
        }
        
        /* --- Chat Window Structure --- */
        .chat-window {
            width: 100%;
            max-width: 48rem; 
            background-color: #ffffff; 
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); 
            display: flex;
            flex-direction: column;
            height: 80vh;
            min-height: 500px;
            overflow: hidden; 
        }
        .header {
            padding: 1rem;
            background-color: #059669; /* Dark green header */
            color: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
        }
        .header h1 {
            font-size: 1.25rem; 
            font-weight: 700;
            margin-left: 0.75rem; 
        }
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: #f9fafb; /* Very light grey chat area */
            display: flex;
            flex-direction: column;
        }

        /* --- Message Bubbles --- */
        .message-row {
            display: flex;
            margin-bottom: 1rem;
        }
        .user-align {
            justify-content: flex-end;
        }
        .bot-align {
            justify-content: flex-start;
        }
        .message-bubble {
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); 
            position: relative;
            max-width: 75%; 
            word-wrap: break-word;
            line-height: 1.4;
        }
        .user-bubble {
            background-color: #10b981; /* Medium green user bubble */
            color: white;
            border-bottom-right-radius: 0.25rem; 
        }
        .bot-bubble {
            background-color: #ffffff; /* White bot bubble */
            color: #1f2937; 
            border-top-left-radius: 0.25rem; 
        }
        .message-text {
            font-size: 0.875rem; 
            font-weight: 400; 
        }
        .message-time {
            font-size: 0.7rem; 
            margin-top: 0.25rem;
            display: block;
            text-align: right;
        }
        .user-time {
            color: #a7f3d0; 
        }
        .bot-time {
            color: #6b7280; 
        }
        .pending-bubble {
            background-color: #e5e7eb !important;
            color: #6b7280 !important;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        /* --- Input Area (Simplified for AI Chat) --- */
        .input-form {
            padding: 1rem;
            background-color: white;
            border-top: 1px solid #e5e7eb; 
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .input-field {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db; 
            border-radius: 9999px; 
            outline: none;
            transition: all 150ms;
            font-size: 0.875rem; 
        }
        .input-field:focus {
            border-color: #10b981;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.5); 
        }
        .send-button {
            width: 48px;
            height: 48px;
            padding: 0;
            border-radius: 9999px; 
            color: white;
            transition: all 150ms;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: none;
        }
        .send-button:disabled {
            background-color: #9ca3af; 
            cursor: not-allowed;
        }
        .send-button:not(:disabled) {
            background-color: #10b981; 
        }
        .send-button:not(:disabled):hover {
            background-color: #059669; 
        }
        .send-button:not(:disabled):active {
            transform: scale(0.95); 
        }

        /* --- Loading Spinner --- */
        .spin {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .loader {
            height: 1.25rem;
            width: 1.25rem;
            border: 2px solid #9ca3af;
            border-top: 2px solid white;
            border-radius: 50%;
        }

        /* --- Icon Sizing --- */
        .icon-large {
            width: 24px;
            height: 24px;
        }
        .icon-small {
            width: 20px;
            height: 20px;
        }
    </style>
</body>
</html>
